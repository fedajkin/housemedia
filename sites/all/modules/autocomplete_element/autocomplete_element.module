<?php
// $Id: autocomplete_element.module,v 1.2.2.1 2010/04/02 14:42:51 b3n Exp $

/**
 * @file
 * Alternative autocomplete_element form element 
 */

/**
* Implementation of hook_menu().
*/
function autocomplete_element_menu() {
  
  $items['autocomplete_element/js'] = array(
    'type' => MENU_CALLBACK,      
    'page callback' => 'autocomplete_element_js',
    'access arguments' => array('access content'),
  );
  
  $items['admin/settings/autocomplete_element'] = array(
    'title' => 'Autocomplete settings',
    'description' => 'Autocomplete element settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('autocomplete_element_admin_settings'),
    'access arguments' => array('administer autocomplete'),
    'file' => 'autocomplete_element.admin.inc',
  );
  
  $items['autocomplete_element/test'] = array(
    'title' => 'autocomplete_element Test',
    'type' => MENU_CALLBACK,    
    'page callback' => 'drupal_get_form',
    'page arguments' => array('autocomplete_element_test_form'),
    'access arguments' => array('access content'),
    'file' => 'autocomplete_element.test.inc',
  );
  
  $items['autocomplete_element/test/js'] = array(
    'type' => MENU_CALLBACK,      
    'page callback' => 'autocomplete_element_test_js',
    'access arguments' => array('access content'),
    'file' => 'autocomplete_element.test.inc',
  );
  
  return $items;

}

/**
 * Implementation of hook_perm().
 */
function autocomplete_element_perm() {
  
  return array('administer autocomplete');
  
}


/**
* Menu callback
* Drupal's default autocomplete paths will be redirected to this callback function 
*/
function autocomplete_element_js() {
  
  $path = ltrim($_GET['path'], '/');
  
  $search_string = $_GET['search'];
  
  $menu_item = menu_get_item($path);
  
  if ($menu_item['file']) {

    require_once($menu_item['file']);

  }
  
  $page_callback = $menu_item['page_callback'];
  
  if (function_exists($page_callback)) {
    
    $page_callback($search_string);
  
  }
  
}


/**
* Implementation of hook_elements().
*/
function autocomplete_element_elements() {
  
  $element['autocomplete'] = array(
    '#input' => TRUE,
    '#process' => array('autocomplete_element_process'),
    '#data' => NULL,
    '#plugin_options' => array(
      'minChars' => 0,
    ),
  );
  
  // If we're overriding default autocomeplete elemtents, add processing
  if (autocomplete_element_variable_get('override')) {
   
    $element['textfield'] = array(
      '#process' => array('autocomplete_element_process'),
    );
    
  }
  
  return $element;
  
}

/**
 * Returns variables set by autocomplete admin settings 
 *
 * @param $name
 *   A string containing the variable name.
 * @return
 *   A mixed value containing the variable.
 */
function autocomplete_element_variable_get($name) {
  
  switch ($name) {
    case 'override':
      $default = TRUE;
    break;  
  }
  
  $variable = sprintf('autocomplete_element_%s', $name);
  
  return variable_get($variable, $default);
  
}

function autocomplete_element_process($element, $edit = array(), $form_state = array(), $complete_form = array()) {
  
  $function_names = array();

  // If it's a normal textfield without an autocomplete path, do nothing
  if ($element['#type'] == 'textfield' &! $element['#autocomplete_path']) {
    
    return $element;
    
  }
  
  autocomplete_element_add_files();
  
  if (is_array($element['#data'])) {  
    $element['#data'] = drupal_to_js($element['#data']); 
  }
  else{
    
    if ($element['#autocomplete_path']) {
      
      $url = '/autocomplete_element/js?path='. $element['#autocomplete_path'];
      $element['#autocomplete_path'] = FALSE;
      $element['#plugin_options']['dataType'] = 'json';
      
    }
    else{
      
      $url = $element['#data'];
      
    }
    
    if (substr($url, 0, 1) != '/') {
      $url = '/'. $url;
    }
    
    $element['#data'] = '"'. $url .'"';
    
  }
  
  // Add some handlers to parse JSON repsonse if none are set
  if ($element['#plugin_options']['dataType'] == 'json') {
    
    if (!isset($element['#plugin_options']['parse'])) {

      $element['#plugin_options']['parse'] = 'acParseJson';
      
    }
    
    if (!isset($element['#plugin_options']['formatItem'])) {
      
      $element['#plugin_options']['formatItem'] = 'acFormatJson';
      
    }
    
  }
    
  if ($element['#plugin_options']['parse']) $function_names[] = $element['#plugin_options']['parse'];
  if ($element['#plugin_options']['formatItem']) $function_names[] = $element['#plugin_options']['formatItem'];
  if ($element['#plugin_options']['formatResult']) $function_names[] = $element['#plugin_options']['formatResult'];
  if ($element['#plugin_options']['formatMatch']) $function_names[] = $element['#plugin_options']['formatMatch'];
  
  $options = autocomplete_element_to_js($element['#plugin_options'], $function_names);
  
  $inline_js = '$().ready(function() {
    $("#'. $element['#id'] .'").autocomplete('. $element['#data'] .', '. $options .');
  })';
  
  drupal_add_js($inline_js, 'inline');
  
  $element['#type'] = 'textfield';
  $element['#default_value'] = $element['#default_value']['autocomplete'];
  $element['#attributes'] = array(
    'class' => 'autocomplete autocomplete-processed', 
    'autocomplete' => 'off'
  );
    
  return $element;
  
}

/**
 * Copy of drupal_to_js allows for function names which won't be enclosed in "
 *
 * @param string $var 
 * @return void
 * @author Ben Scott
 */
function autocomplete_element_to_js($var, $function_names = array()) {
  
  switch (gettype($var)) {
    case 'boolean':
      return $var ? 'true' : 'false'; // Lowercase necessary!
    case 'integer':
    case 'double':
      return $var;
    case 'resource':
    case 'string':
    
      if (in_array($var, $function_names)) {
        
        return $var;
        
      }
      else{
    
        return '"'. str_replace(array("\r", "\n", "<", ">", "&"),
                                      array('\r', '\n', '\x3c', '\x3e', '\x26'),
                                      addslashes($var)) .'"';
        
      }
    
    case 'array':
      // Arrays in JSON can't be associative. If the array is empty or if it
      // has sequential whole number keys starting with 0, it's not associative
      // so we can go ahead and convert it as an array.
      if (empty ($var) || array_keys($var) === range(0, sizeof($var) - 1)) {
        $output = array();
        foreach ($var as $v) {
          $output[] = autocomplete_element_to_js($v, $function_names);
        }
        return '[ '. implode(', ', $output) .' ]';
      }
      // Otherwise, fall through to convert the array as an object.
    case 'object':
      $output = array();
      foreach ($var as $k => $v) {
        $output[] = autocomplete_element_to_js(strval($k), $function_names) .': '. autocomplete_element_to_js($v, $function_names);
      }
      return '{ '. implode(', ', $output) .' }';
    default:
      return 'null';
  }
}

/**
 * Take results and echo them out on a new line to be used by jquery.autocomplete
 *
 * @param string $results 
 * @return void
 * @author Ben Scott
 */
function autocomplete_element_output($results) {
  
  if (count($results)) {
    
    foreach ($results as $result) {
      
      echo $result;
      echo "\n";
      
    }
    
  }
  
}


function autocomplete_element_add_files() {
  
  $path = drupal_get_path('module', 'autocomplete_element');
  
  drupal_add_js($path .'/js/autocomplete.js');
  drupal_add_js($path .'/js/jquery.autocomplete.js');
  drupal_add_js($path .'/js/jquery.ajaxQueue.js');
  drupal_add_js($path .'/js/jquery.bgiframe.min.js');
  
  drupal_add_css($path .'/css/jquery.autocomplete.css');
  drupal_add_css($path .'/css/autocomplete_element.css');
  
}